Here’s a **tight, Copilot-optimized prompt** you can paste into a new `README_COPILOT.md` (or into Copilot Chat). It authorizes **git + shell** and gives Copilot a concrete game plan, directory tree, commands, and commit points. It keeps the **FIFO summarization → RAG** loop, but now Copilot may scaffold scripts and **run** them (git operations allowed).

---

# COPILOT MASTER PROMPT — MQTT Multi-Language Pub/Sub + Encoding Comparison

## Role

You are a **cloud-architect’s build bot**. Your job is to **create a complete tutorial repository** comparing **MQTT publishing/consuming** and **encoding/decoding** across **Python, Rust, C, C++, Julia, R, and C#**, with runnable examples and a minimal benchmarking harness.

## Permissions

* You **may** use **shell** and **git**.
* You **must** generate **files, code, and scripts** that are committed in coherent increments.
* Prefer **portable** solutions; keep images small; use pinned versions where reasonable.

## High-Level Goals

1. Stand up a **local Mosquitto** broker via Docker Compose.
2. Scaffold **language pairs** (publisher/subscriber) with **JSON baseline**, plus **MessagePack, CBOR, Protobuf** encoders where feasible.
3. Standardize topics, QoS, payload sizes; provide CLI flags per language.
4. Provide a **benchmark harness** that can orchestrate language pairs and persist results.
5. Implement a **FIFO summarization → RAG** loop that condenses phases into digest files to avoid infinite context growth.
6. Add **CI sanity checks** (lint/build/run smoke tests).

## Technical Contracts

* **Topic:** `mqtt-demo/all` (also allow `mqtt-demo/<lang>/<role>`).
* **QoS:** default **1**; configurable.
* **Payload variants:** `small` (~128B), `medium` (~2KB), `large` (~64KB).
* **Broker URI:** `mqtt://localhost:1883`.
* **Encodings:** JSON (baseline), MessagePack, CBOR, Protobuf (add incrementally).
* **Metrics:** publish latency p50/p95, receive latency p50/p95, throughput msgs/s, payload bytes, (optional) encode/decode time.

## Repository Layout (create exactly this)

```
.
├─ README.md
├─ .editorconfig
├─ .gitignore
├─ LICENSE
├─ CONTRIBUTING.md
├─ CODE_OF_CONDUCT.md
├─ broker/
│  ├─ docker-compose.yml
│  └─ mosquitto.conf
├─ schema/
│  ├─ message.schema.json
│  ├─ message.cddl
│  ├─ message.proto
│  └─ messagepack.md
├─ benchmarks/
│  ├─ plan.md
│  ├─ runner.py
│  └─ Makefile
├─ python/        (publisher.py, subscriber.py, enc_* modules, requirements.txt)
├─ rust/          (Cargo.toml, src/bin/{publisher.rs,subscriber.rs})
├─ c/             (Makefile, src/publisher.c, src/subscriber.c)
├─ cpp/           (CMakeLists.txt, src/publisher.cpp, src/subscriber.cpp)
├─ julia/         (Project.toml, src/publisher.jl, src/subscriber.jl)
├─ r/             (DESCRIPTION, scripts/publisher.R, scripts/subscriber.R)
├─ csharp/        (MqttDemo.csproj, Publisher.cs, Subscriber.cs)
├─ docs/
│  ├─ overview.md
│  ├─ CHANGELOG.md
│  └─ _summaries/
│     ├─ PHASE-000.md
│     └─ PHASE-META-ROLLUP.md  (created once ≥5 summaries exist)
├─ results/       (git-kept; add .keep)
└─ tools/
   ├─ summarize_phase.py    (FIFO RAG summary tool)
   └─ smoke.sh              (quick repo smoke: broker up, python pub/sub)
```

## RAG / FIFO Summarization Loop

* Each **phase** ends with a summary written to `docs/_summaries/PHASE-###.md` containing:

  * Created/changed files list, short rationale, TODOs for next phase, ≤20-line reusable snippets.
* When summaries reach **5**, generate/update `PHASE-META-ROLLUP.md` by **merging the oldest 3**, then **delete those 3** (FIFO), keeping the rollup as retained knowledge.
* Provide `tools/summarize_phase.py` to:

  * Detect changed files since last tag/marker.
  * Write the new phase summary.
  * Maintain FIFO + rollup.
* Commit summaries as part of each phase.

## Phase Plan (execute sequentially; commit at end of each)

**Phase 0 — Bootstrap**

* Create repo skeleton, broker, schemas, baseline Python pub/sub with JSON + MessagePack, docs.
* Add `tools/summarize_phase.py` and `tools/smoke.sh`.
* Commit: `feat(bootstrap): scaffold repo, broker, schemas, python baseline`

**Phase 1 — Python Parity & Mini-Bench**

* Python publisher/subscriber flags: `--enc {json,msgpack}`, `--payload {small,medium,large}`, `--qos {0,1}`.
* Add minimal timing (send ts, receive ts) → write JSON result to `results/python/`.
* Update `benchmarks/runner.py` to orchestrate Python test.
* Commit: `feat(python): JSON+msgpack, flags, minimal timings`

**Phase 2 — Rust Implementation**

* `rumqttc`, `serde_json`, `rmp-serde`. Implement parity with Python (JSON/MsgPack).
* Commit: `feat(rust): pub/sub parity with python`

**Phase 3 — C & C++**

* C: `paho.mqtt.c`; C++: `paho-mqttpp3` (or `mqtt_cpp`), start JSON baseline.
* Commit: `feat(c,cpp): baseline pub/sub`

**Phase 4 — Julia, R, C#**

* Julia: `MQTT.jl` + `JSON3.jl` baseline; R: available client + `jsonlite`; C#: `MQTTnet` + `System.Text.Json`.
* Commit: `feat(julia,r,csharp): baseline JSON pub/sub`

**Phase 5 — CBOR & Protobuf (where feasible)**

* Introduce CBOR (`cbor2`/`serde_cbor`/equiv) and Protobuf (.proto in `schema/`) per language support.
* Commit: `feat(encodings): cbor+protobuf across supported langs`

**Phase 6 — Unified Benchmark**

* Extend `benchmarks/runner.py` to call each lang, collect CSV/JSON to `results/`, and produce a `docs/overview.md` table.
* Commit: `feat(benchmarks): unified harness + results table`

At each phase, run `tools/summarize_phase.py` → commit `PHASE-###.md` and update `docs/CHANGELOG.md`.

## Required Implementation Details

1. **Broker** (`broker/docker-compose.yml`)

   * `eclipse-mosquitto:2`, ports `1883`, optional websocket `9001`, `allow_anonymous true` for local dev.
2. **Schema** (`schema/`)

   * Keep `message.schema.json`, `message.cddl`, `message.proto`, `messagepack.md` aligned.
3. **Python**

   * `paho-mqtt`, `orjson`, `msgpack`; publisher/subscriber with flags; emit minimal timing.
4. **Rust**

   * `rumqttc`, `serde_json`, `rmp-serde`; mirror Python CLI flags with `clap`.
5. **C/C++**

   * Build with `Makefile`/`CMakeLists.txt`; keep code small and readable.
6. **Julia/R/C#**

   * Provide minimal working JSON baseline + README usage.
7. **Benchmarks**

   * `benchmarks/runner.py` accepts `--lang`, `--enc`, `--payload`, `--qos`, `--count`.
   * Warmup vs measured iterations; write per-run JSON file to `results/<lang>/`.
8. **CI**

   * Add `.github/workflows/smoke.yml`:

     * Spin up broker
     * Run python subscriber/publisher for JSON small QoS1
     * (Matrix jobs later)

## Shell Script & Tooling (have Copilot generate these)

* `tools/smoke.sh`: bring broker up, run python sub/pub, assert exit 0.
* `tools/summarize_phase.py`: detect changes since last phase marker (use `git tag` or a `.phase` counter file), produce `docs/_summaries/PHASE-###.md`, enforce FIFO + rollup.
* `benchmarks/Makefile`: targets `python`, `rust`, `all`, `clean`.

## Git Hygiene

* Create `.gitignore` for:

  * `__pycache__/`, `.venv/`, `target/`, `build/`, `*.o`, `*.so`, `.DS_Store`, `results/**/*.tmp`, `broker/{data,log}/`
* Each phase = **one or a few commits** with meaningful messages.
* Optionally tag phases: `v0-phase0`, `v0-phase1`, …

## Mermaid: Build Flow (include in `README.md`)

```mermaid
flowchart LR
  A[Phase N: Implement] --> B[tools/summarize_phase.py]
  B --> C[docs/_summaries/PHASE-###.md]
  C --> D[PHASE-META-ROLLUP (when ≥5)]
  D --> E[FIFO: delete oldest 3]
  A --> F[git commit + optional tag]
  F --> G[benchmarks/runner.py -> results/]
  G --> H[docs/overview.md table update]
```

## Now Do This (ordered tasks Copilot should execute)

1. **Initialize repo & hygiene**

   * Create all files/dirs per layout, including `.keep` in `results/`.
   * Write `README.md` with quick start, per-lang run commands, benchmark usage, and mermaid flow.
   * Add `.gitignore`, `.editorconfig`, MIT `LICENSE`, `CODE_OF_CONDUCT.md`, `CONTRIBUTING.md`.
   * **Commit:** `chore: init repo skeleton`

2. **Broker & schemas**

   * Add `broker/docker-compose.yml` + `mosquitto.conf`.
   * Add schema files (`json/cddl/proto/msgpack.md`).
   * **Commit:** `feat(broker,schemas): mosquitto + message schemas`

3. **Python baseline**

   * Implement `python/src/{publisher.py,subscriber.py,enc_json.py,enc_msgpack.py}` + `requirements.txt`.
   * Minimal timings and `--enc/--payload/--qos` flags.
   * Add `tools/smoke.sh` to run a quick sub/pub loop; make executable.
   * **Commit:** `feat(python): baseline pub/sub + msgpack + smoke`

4. **RAG summarization tool**

   * Implement `tools/summarize_phase.py`:

     * Track current phase in `.phase` (start at 000).
     * Collect changed file list (`git diff --name-only` from previous tag/phase marker).
     * Write `docs/_summaries/PHASE-###.md` with created/changed files, rationale, TODOs, and ≤20-line snippets.
     * If summaries ≥5, create/update `PHASE-META-ROLLUP.md` (merge oldest 3), then delete those 3 and advance.
   * Run it; create `PHASE-000.md`.
   * **Commit:** `chore(RAG): add FIFO phase summarizer + PHASE-000`

5. **Benchmarks harness skeleton**

   * Implement `benchmarks/runner.py` to orchestrate Python sub/pub and persist JSON results.
   * Add `benchmarks/Makefile` targets and `plan.md`.
   * **Commit:** `feat(benchmarks): runner skeleton + make targets`

6. **Rust parity (Phase 2)**

   * Add rust pub/sub with JSON + MessagePack parity.
   * Update runner to optionally call rust pair.
   * Summarize & commit.

7. **C/C++ (Phase 3), Julia/R/C# (Phase 4), Encodings (Phase 5), Unified Harness (Phase 6)**

   * Proceed as per Phase Plan; summarize each phase; commit.

> After each step: run `tools/smoke.sh`. After each phase: run `tools/summarize_phase.py`, commit, and (optionally) tag.

## Non-Goals (keep scope sharp)

* No cloud MQTT brokers; local only.
* No advanced security (PSKs/TLS) in v0; add later if needed.
* No plotting dashboards; raw results only.

---

**Begin execution now following the “Now Do This” list.**
